# FI FLAT

~~Много~~Функциональный, интерпретируемый язык программирования написанный на языке F#.

```
let program {
    print "Hello, world!";
}
```

Разработчики: [Тимофей Голубев](https://github.com/cat-mood), [Бонокин Данил](https://github.com/Bonik0), [Филиппов Владимир](https://github.com/zloyaloha)

Репозиторий с исходниками [**туть**](https://github.com/MAILabs-Edu-2024/fp-compiler-lab-hockey-s-head)

## Оглавление

## Введение

Однажды в Московском Авиационном Институте учились три студента. И вот на втором курсе у них появился предмет **функциональное программирование**, на котором они столкнулись с необычайно интересным и захватывающим языком **F#**. Жили они, не тужили, пока в один момент преподаватель не сказал им: "Мало вам просто язык изучить. Попробуйте-ка вы свой написать!". Почесали они свою репу, поразмыслили, да начали делать, а кабы не делали, то лишились бы ~~жизни~~ стипендии. Вот как-то так и появился проект, который вы изучаете.

## Преимущества и недостатки функционального программирования

В курсе функционального программирования мы познакомились с замечательным языком программирования F#. Он дает возможность писать компактно и красиво, заставляет разработчика больше думать, что он делает, а не как это сделать. С точки зрения бизнеса – это очень полезная вещь, так как дает возможность разработчикам больше смотреть на код с точки зрения продукта, а не процесса. Еще можно выделить следующие приемущества функционального подхода:

+ **Повышение надёжности кода**.
Привлекательным является тот факт, что функциональный код лучше структурирован. Кроме того, не нужно отслеживать побочные эффекты выполнения функции, так как они работают исключительно с локальными данными. Невозможность мутации данных при пользовании ими в разных местах программы исключает появление труднообнаруживаемых ошибок.

+ **Удобство организации тестирования**.

Имеется возможность протестировать каждую функцию в программе, просто вычислив её от различных наборов значений аргументов. При этом можно не беспокоиться ни о вызове функций в правильном порядке, ни о правильном формировании внешнего состояния. Если любая функция в программе проходит модульные тесты, то можно быть уверенным в качестве всей программы. В императивных программах проверка возвращаемого значения функции недостаточна: функция может модифицировать внешнее состояние, которое тоже нужно проверять, чего не нужно делать в функциональных программах.

+ **Возможности оптимизации при компиляции**.

Традиционно упоминаемой положительной особенностью функционального программирования является то, что оно позволяет описывать программу в так называемом «декларативном» виде, когда жесткая последовательность выполнения многих операций, необходимых для вычисления результата, в явном виде не задаётся, а формируется автоматически в процессе вычисления функций. Это обстоятельство, а также отсутствие состояний даёт возможность применять к функциональным программам достаточно сложные методы автоматической оптимизации.

+ **Возможности параллелизма**.

Ещё одним преимуществом функциональных программ является то, что они предоставляют широчайшие возможности для автоматического распараллеливания вычислений. Поскольку отсутствие побочных эффектов гарантировано, в любом вызове функции всегда допустимо параллельное вычисление двух различных параметров — порядок их вычисления не может оказать влияния на результат вызова.

Однако же, несмотря на все плюсы функционального программирования, полностью поменять подход в контексте современного мира у нас не получится.  Это очень дорого и нецелесообразно: надо переучивать большое количество разработчиков, встраивать новые куски в старый legacy-код. Кроме того, можно выделить и недостатки которые вытекают из преимуществ функционального подхода: отсутствие присваиваний и замена их на порождение новых данных приводят к необходимости постоянного выделения и автоматического освобождения памяти, поэтому в системе исполнения функциональной программы обязательным компонентом становится высокоэффективный сборщик мусора.

Однако современные языки развиваются так, что в них по-тихоньку приходят некоторые элементы функционального программирования: лямбда-выражения, функции высших порядков, чистые функции и так далее. Примером таких языков могут служить Python, C++, Java и многие другие. 


## Решение

Для начала мы разбили нашу задачу на несколько этапов. 

+ Изучение существующих функциональных языков программирования
+ Разработка синтаксиса собственного языка
+ Создание лексера и парсера
+ Написание интерпретатора
+ Создание примеров программ и документации

Расскажем про всё по порядку

### Существующие языки
### Lisp
Сначала нам на глаза попался язык программирования **LISP**. Это очень красивый и элегантный язык программирования.

Автором Лиспа является Джон Маккарти, на период создания языка работавший в Массачусетском технологическом институте (MIT) в должности профессора по связи. Исторически первой реализацией Лиспа, включающей все современные базовые элементы языка, был интерпретатор, работавший на IBM 704, появившийся в октябре 1958 года.

Базовыми элементами языка являются символы, атомы и построенные из них динамические списочные структуры — S-выражения. Любая программа на языке Лисп состоит из последовательности выражений (форм). Результат работы программы состоит в вычислении этих выражений. Все выражения записываются в виде списков — одной из основных структур Лиспа, поэтому они могут легко быть созданы посредством самого языка. Это позволяет создавать программы, изменяющие другие программы или макросы, позволяющие существенно расширить возможности языка.

Вот так на LISP выглядит операция **взятия головы** списка

```lisp
(CAR '(A B C D)) ; -> A
```

**Суммирование чисел** от 1 до 5

```lisp
(+ 1 2 3 4 5) ; -> 15
```

**Определение функции**  вычисление квадрата суммы двух чисел

```lisp
(DEFUN SUMKVAD (X Y)
 (+ (* X X) (* Y Y))
)
```

В общем язык красивый и прикольный, но хотелось чего-то более знакомого...
### F#

F# впервые увидел свет в 2005 году в Microsoft Research. Это мультипарадигмальный язык для платформы Microsoft .NET, нацеленный преимущественно на функциональное программирование.

Как и другие функциональные языки, F# нацелен на упрощение работы с Big Data и многопоточностью, то есть востребован в науке, в создании искусственного интеллекта, там, где используются динамические базы данных, а также для улучшенного использования ресурсов многоядерных процессоров. Иначе говоря, F# можно использовать практически везде, будь на то ваша воля.

Определение функции **сложения двух чисел**

```fsharp
let sum a b = a + b
let result = sum 5 3
```

Рекурсивная функция нахождения **факториала** числа
```fsharp
let rec fac n =
   if n < 2 then 1
   else n * fac(n - 1)
```

## Синтаксис
Сначала мы, как я уже упомянул, хотели взять синтаксис LISP'а, но по итогу передумали Мы взяли синтаксис F# и доработали его под наши нужды. Получился некий сплав C++ и F#.

***Ниже вы можете увидеть примеры базовых конструкций языка.***

* Функции
```
let func_name param1 param2 {
    func1 param1;
    func2 param1 param2;
}
```
* Именнованные переменные
```
let var_name {val}
```
*Лямбда-выражения
```
let lambda_example num {lambda a : + a 1}
```
Обратите внимание, что операторы работают в **постфиксной нотации**.
```
let varname { + 1 2}
```

```
let x param {
    if > param 1 {
        printfn 1
    } else {
        printfn 2
    }
};
```
## Парсер и лексер

Парсер и лексер в нашем случае фактически объединены. Сразу после того, как отрабатывает лексер в дело вступает парсер, который преобразовывает лексемы в выражения типа `expr`.

```fsharp
type expr = 
| Int of int
| Var of string
| Bool of bool
| Let of string*expr
| LetRec of string*expr
| BinOp of string*expr*expr
| Cond of expr*expr*expr
| Lambda of string*expr
| Exec of expr*list<expr>
| Void of unit
| Closure of expr*env
| RClosure of expr*env*string
| Env of env
| Builtin of string*list<expr>
and env = Map<string, expr>
```

При рассмотрении кода мы будем обращать внимание на приемы функционального программирования и как это может быть реализовано в императивном языке программирования C++.

**Лексер имен переменных**
```fsharp
let diveders_parser = spaces <|> skipMany (pchar '\n') <|> skipMany (pchar '\t')

let var_name_parser = diveders_parser >>. many1Chars2 (letter <|> pchar '_') (letter <|> digit <|> pchar '_') .>> diveders_parser
```
Напримере этого лексера мы можем увидеть применение приемов функционального программирования.

1. **Композиция функций и высшие функции**: Оператор `<|>` и `>>` используются для композиции парсеров. Оператор `<|>` представляет выбор между двумя парсерами, а `>>` используется для последовательного применения двух парсеров.

В C++ мы часто встречаемся с композицией в функциях STL. Например функция ``transform``, которая может применять к каждому элементу контейнера ``foo`` функцию ``increase`` и вставлять результат в контейнер ``bar``
```cpp
int increase (int i) { return ++i; }

int main () {
    std::vector<int> foo;
    std::vector<int> bar;

    for (int i=1; i<6; i++)
        foo.push_back (i*10);  // foo: 10 20 30 40 50

    bar.resize(foo.size());

    std::transform (foo.begin(), foo.end(), bar.begin(), increase);  // bar: 11 21 31 41 51
}
```

2. **Каррирование и частичное применение**: Функция `many1Chars2` принимает два аргумента, каждый из которых является функцией.

Без STL каррирование можно реализовать следующим образом:

```cpp
int sum2(int lhs, int rhs) {
  return lhs + rhs;
}
auto curried_sum2(int lhs) {
  return [=](int rhs) {
    return sum2(lhs, rhs);
  };
}
```

```cpp
//output 10
std::cout << sum2(3, 7) << std::endl;
std::cout << curried_sum2(7)(3) << std::endl;
```

Частичное применение и каррирование на C++ можно реализовать при помощи функции ``std::bind``

```cpp
int foo(int v1, int v2, int v3, int v4) {
  return v1 + v2 + v3 + v4;
}

auto c0 = std::bind(foo, _1, _2, _3, _4);
auto c1 = std::bind(c0, 15, _1, _2, _3);
auto c2 = std::bind(c1, 20, 2, _1);
auto rr = c2(5);
std::cout << rr << std::endl; // output: 42
```

Каррирование и частичное применение удобно в тех случаях, когда нам необходимо зафиксировать один из аргументов у функции N аргументов, сделав из нее функцию N-1 аргументов. Таким образом можно уменьшить количество написанного кода, улучшить читабельность.

**Лексер вызовов функций**
```
let exec_parser = 
    pipe2 (val_name_parser) (sepEndBy val_name_parser spaces .>> skipChar ';') (fun x y -> ExecData(x, y))
```
**Лексер let-конструкций**
```fsharp
let body_parser, body_parser_ref = createParserForwardedToRef ()

let Let_parser = pipe3 (diveders_parser >>. let_parser >>. var_name_parser) (params_parser) (pchar '{' >>. diveders_parser >>. body_parser .>> diveders_parser .>> pchar '}') (fun x y z -> Let(x, transform_params_into_lambda y z))

do body_parser_ref.Value <- choice [attempt Let_parser; attempt Final_binop_parser; attempt Bool_parser; attempt Int_parser; attempt Exec_parser; attempt Lambda_parser]
```
На его примере мы можем увидеть ~~парсинг~~ лексинг сложных рекурсивных выражений. Внутри let_parser'а вызывается лексер тела выражения, в котором может начать токенизироваться либо функция, либо снова let-выражения. 

Тут мы видим следующие примеры использования функциональных приемов:

1. **Замыкания и лямбда-функции**. Анонимная функция `fun x y z -> Let(x, transform_params_into_lambda y z)` является замыканием, поскольку она захватывает переменные `x`, `y` и `z`, а также функцию `transform_params_into_lambda` из окружающей области видимости.

На C++ анонимные функции могут выглядеть следующим образом:

```cpp
auto add = [](auto x, auto y) {
  return x + y;
};
auto sub = [](auto x, auto y) {
  return x - y;
};
auto mul = [](auto x, auto y) {
  return x * y;
};
```

А вот замыкания будут выглядеть вот так:

```cpp
auto identityf = [](auto x) {
  return [=]() { return x; };
};
identityf(5)(); // 5
```

Замыкания позволяют создать функцию с доступом к данным вне ее области видимости. Это полезно, когда нет особой необходимости плодить аргументы функции.

2. **Иммутабельность**. Парсеры не изменяют входные данные, а создают новые структуры данных на основе входных данных и правил парсинга. Это соответствует принципу иммутабельности в функциональном программировании.

Иммутабельность по сути обозначает константность, только в более строгом ее понимании. Объект не может менять ни свое состояние, ни свои данные. В C++ это реализуется при помощи ключевого слова `const` во всех местах, где только можно. Это полезная вещь, которая может использоваться во имя избегания побочных эффектов, например, в разработке параллельных приложений.

3. **Отложенные вычисления**. Парсеры определяются декларативно и вычисляются только при их применении к входным данным. Это достигается за счет использования ленивых вычислений в библиотеке FParsec.
   
Отложенные вычисления - это очень хорошая оптимизация. При помощи этого приема мы можем вычислять значение выражения только в тот момент, когда оно нам понадобилось. Принцип действия можно объяснить напримере этого куска кода. Вычисления значения переменной `result` при ленивой стратегии произойдет только на 8 строке, когда оно понадобиться нам для вывода в консоль.

```cpp
int multiply(int x, int y) { return x * y; }

int main() {
    int x = 2, y = 3;
    int tmp = multiply(x, y);
    int result = multiply(4, tmp);
    // ... and many other calculations ...
    cout << "result: " << result << "\n";
}
```

Но в C++ нет поддержки ленивых вычислений, это лишь пример того, как это могло бы работать. Зато есть в Python. Самым ярким примером использования ленивых вычислений в Python является функция `range(int)`. В python2 она возращала список длины 5. При увеличении промежутка для хранения списка требовалось все больше и больше памяти. В python3 ситуация изменилась и функция `range(int)` возвращает уже объект типа `range`. Чтобы получить последовательность чисел, этот объект надо проитерировать. Независимо от того, насколько велика последовательность чисел, сам объект всегда имеет один и тот же размер. Дело в том, что `range(5)` хранит только значения `start`, `stop` и `step`, а каждый элемент вычисляет по мере необходимости. По этому же принципу работают функции `zip`, `map`, `open` и другие

Так выглядить преобразователь из списка токенов в нормальные человеческие выражения.

Реализации остальных парсеров можно посмотреть [здесь](https://github.com/MAILabs-Edu-2024/fp-compiler-lab-hockey-s-head/blob/main/Program.fs)

## Интерпретатор
Наш интерпретатор работает по принципу ***eval-apply***. Как заметно по названию, такой интерпретатор содержит две основные функции - функцию `eval`, вычисляющую значение выражения в заданном контексте переменных, и функцию `apply`, которая вычисляет результат применения некоторой функции к заданному значению аргумента, т.е. выполняет один шаг редукции выражения.

Работу такого интерпретатора можно разбить на такие шаги:
1. Читает следующее выражение из программы.
2. Вызывает eval, передавая ему выражение и текущую среду.
3. Eval анализирует выражение и определяет, как его обработать.
4. Если необходимо вызвать функцию, вызывает apply, передавая ему функцию и аргументы.
5. Apply вычисляет результат вызова функции.
6. Eval возвращает результат вычисления выражения.
7. Интерпретатор продолжает выполнение программы, повторяя шаги 1-6.

По такому принципу работают интерпретаторы таких функциональных языков, как Lisp и Scheme.

Давайте разберем работу интерпретатора и посмотрим, какие функциональные приемы при этом используются.

Для начала вспомним наш тип выражения `expr`, который понадобится нам для понимания работы интерпретатора. 

```fsharp
type expr = 
| Int of int
| Var of string
| Bool of bool
| Let of string*expr
| LetRec of string*expr
| BinOp of string*expr*expr
| Cond of expr*expr*expr
| Lambda of string*expr
| Exec of expr*list<expr>
| Void of unit
| Closure of expr*env
| RClosure of expr*env*string
| Env of env
| Builtin of string*list<expr>
and env = Map<string, expr>
```
А вот и ***eval-apply*** часть интерпретатора. Принцип работы был описан выше: выбирается выражение, мы пытаемся его сопоставить с каким-то известным, далее либо снова вызываем `eval` для разборки рекурсивного выражения, либо вычисляем выражение при помощи `apply`.

```fsharp
let rec eval (exp: expr) (env: env) = 
    match exp with
    | Int(x) -> Int(x)
    | Bool(x) -> Bool(x)
    | Var(x) -> 
        try Map.find x env with
        | :? System.Collections.Generic.KeyNotFoundException -> Void(printfn "There is no variable %s" x)
    | BinOp(op, x, y) -> binop op (eval x env) (eval y env)
    | Let(id, func) -> 
        let new_func = eval func env
        Env(Map.add id new_func env)
    | LetRec(id, func) ->
        Env(Map.add id (RClosure(func, env, id)) env)
    | Lambda(var, func) -> Closure(exp, env)
    | Builtin(name, args) -> builtin name (List.map (fun x -> eval x env) args) env
    | Cond(c, e1, e2) ->
        let eval_c = (eval c env) in
        match eval_c with
        | Bool(true) -> (eval e1 env)
        | Bool(false) -> (eval e2 env)
        | _ -> Void(printfn "Conditional error")
    | Exec(exp1, []) -> exp1
    | Exec(exp1, exp2 :: tail) ->
        eval (Exec((apply (eval exp1 env) (eval exp2 env)), tail)) env
    | Closure(a, b) -> Closure(a, b)
    | RClosure(a, b, c) -> RClosure(a, b, c)
and apply e1 e2 =
    match e1 with
    | Closure(Lambda(v, e), env) -> 
        eval e (Map.add v e2 env)
    | RClosure(Lambda(v,e),env, id) -> 
        eval e (Map.add v e2 (Map.add id e1 env))
```

1. **Pattern matching.** Это очень удобный способ анализировать и обрабатывать информацию, основанный на выполнении определённых инструкций в зависимости от совпадения исследуемого значения с тем или иным образцом, в качестве которого может использоваться константа, предикат, тип данных.

В нашем случае, при помощи сопоставления с образцом, мы выбираем какие инструкции нужно применить к конкретному выражению типа `expr`. 

В стандарте `C++` нет поддержки *pattern matching'a*, но он есть, например, в Python. На его примере и посмотрим, как он работает.

Синтаксис конструкции выглядит следующим образом.

```python
match some_expression:
    case pattern_1:
        ...
    case pattern_2:
        ...
```

Использовать сопоставление с образцом можно примерно так же, как и `switch-case` конструкции. В целом, на мой взгляд, pattern-matching и есть несколько улучшенный switch. Но сейчас не об этом.

```python
match number:
    case 42:
        print('good number')
    case 43:
        print('not good number')
```

Можно захватывать локальные переменные в данной конструкции. Так же тут мы можем увидеть так называемый `default case`, который будет использоваться, если не подошли остальные.

```python
match greeting:
    case _:
        print('Hello my friend')
    case name:
        print(f'Hello  {name}')
```

Также можно обрабатывать, например, списки:

```python
answer = [42]
match answer:
    case []:   
        print('i do not find answer')
    case [x]:
        print(f'asnwer is {x}')
    case [x, *_]:
        print('i find more than one answers')
```

А еще можно обрабатывать классы.

```python
class Coordinate:
    __match_args__ = ['x', 'y', 'z']

    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

сoordinate = Сoordinate(1, 2, 3)
match Сoordinate:
    case Сoordinate(0, 0, 0):
        print('Zero Сoordinate')
    case Сoordinate(x, y, z) if z == 0:
        print('Сoordinate in the plane Z')
    case _:
        print('Another Сoordinate')
```
Однако, на самом деле, такие конструкции в `Python` по итогу преобразуются в эквивалентные `if-else` конструкции. Так что конечно это больше синтаксический сахар. Но все же приятно.

Итого, при помощи `сопоставления с образцом` мы можем красиво (а главное удобно) обрабатывать различные структуры данных.

## Вывод
При выполнении лабораторной работы мы познали, насколько интересно и одновременно сложно писать свой язык программирования. Мы поняли, как работают парсеры и лексеры, как написать свой интерпретатор, какие сложности и подводные камни существуют и как можно наш язык улучшить. 

В тоже время, мы осознали насколько мощный инструмент F#. С его помощью можно более красиво и элегантно написать то, что в традиционном языке программирования заняло не одну сотню строк. Мы глубже познакомились с устройством работы языка F#.

Кроме того, мы познакомились с некоторомы приёмами функционального программирования, посмотрели, как их можно использовать в классических императивных языках. С их помощью мы сможем писать более понятный, чистый и эффективный код. 

Знания, которые мы получили при выполнении данной работы, будут полезны любому разработчику, так как **функциональность** написанного кода во многом улучшает его качество.

